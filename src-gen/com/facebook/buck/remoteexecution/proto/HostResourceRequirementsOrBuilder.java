// @generated
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remoteexecution/proto/metadata.proto

package com.facebook.buck.remoteexecution.proto;

@javax.annotation.Generated(value="protoc", comments="annotations:HostResourceRequirementsOrBuilder.java.pb.meta")
public interface HostResourceRequirementsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:facebook.remote_execution.HostResourceRequirements)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>int64 mem_bytes = 1;</code>
   */
  long getMemBytes();

  /**
   * <pre>
   * Number of cpu that action needs. For e.g., set to 2 if you need 2 threads.
   * </pre>
   *
   * <code>int64 cpu_units = 2;</code>
   */
  long getCpuUnits();

  /**
   * <pre>
   * List of affinities requested by actions, sorted by client-decided priority. RE will try to schedule actions with same affinity key
   * on same hosts, for better cache locality. RE will try to schedule this action to a host which recently ran affinity_keys[0], if it cannot
   * find such free host, then one which ran affinity_keys[1]... and so on, finally falling back to run on a random host.
   * </pre>
   *
   * <code>repeated string affinity_keys = 3;</code>
   */
  java.util.List<java.lang.String>
      getAffinityKeysList();
  /**
   * <pre>
   * List of affinities requested by actions, sorted by client-decided priority. RE will try to schedule actions with same affinity key
   * on same hosts, for better cache locality. RE will try to schedule this action to a host which recently ran affinity_keys[0], if it cannot
   * find such free host, then one which ran affinity_keys[1]... and so on, finally falling back to run on a random host.
   * </pre>
   *
   * <code>repeated string affinity_keys = 3;</code>
   */
  int getAffinityKeysCount();
  /**
   * <pre>
   * List of affinities requested by actions, sorted by client-decided priority. RE will try to schedule actions with same affinity key
   * on same hosts, for better cache locality. RE will try to schedule this action to a host which recently ran affinity_keys[0], if it cannot
   * find such free host, then one which ran affinity_keys[1]... and so on, finally falling back to run on a random host.
   * </pre>
   *
   * <code>repeated string affinity_keys = 3;</code>
   */
  java.lang.String getAffinityKeys(int index);
  /**
   * <pre>
   * List of affinities requested by actions, sorted by client-decided priority. RE will try to schedule actions with same affinity key
   * on same hosts, for better cache locality. RE will try to schedule this action to a host which recently ran affinity_keys[0], if it cannot
   * find such free host, then one which ran affinity_keys[1]... and so on, finally falling back to run on a random host.
   * </pre>
   *
   * <code>repeated string affinity_keys = 3;</code>
   */
  com.google.protobuf.ByteString
      getAffinityKeysBytes(int index);

  /**
   * <pre>
   * Total size of the files used as input for the action.
   * </pre>
   *
   * <code>int64 input_files_bytes = 4;</code>
   */
  long getInputFilesBytes();
}
